<!DOCTYPE html>

<meta charset="utf-8">
<head>    
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="pygment_trac.css">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <meta name="description" content="MSAN 622 Submission Page - Homework 2">
</head>
<style>
    #writeup {
        width: 100%;
    }

    #functionality {
        width: 50%;
        float: left;
        padding: 5px;
        margin-right: 15px;
    }

    #plot {
        margin-left: auto;
        margin-right: auto;
    }

    .axis text {
        font: 10px sans-serif;
    }

    .axis path,
    .axis line {
        fill: none;
        stroke: darkgray;
        shape-rendering: crispEdges;
    }

    .x.axis path {
        fill: none;
        stroke: darkgray;
        shape-rendering: crispEdges; 
        /*display: none;*/
    }

    .x.axis2 path {
/*        fill: none;
        stroke: darkgray;
        shape-rendering: crispEdges; */
        display: none;
    }
    .axis2 text {
        font: 10px sans-serif;
    }
    .axis3 line,
    .axis3 path {
    fill: none;
    stroke: #000;
    shape-rendering: crispEdges;
    }
    
    .axis3 text {
        font: 10px sans-serif;
        text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
    }
    .d3-tip {
      line-height: 1;
      font-weight: bold;
      padding: 12px;
      background: rgba(44,123,182, 0.9);
      color: #fff;
      border-radius: 5px;
    }

    /* Creates a small triangle extender for the tooltip */
    .d3-tip:after {
      box-sizing: border-box;
      display: inline;
      font-size: 10px;
      width: 100%;
      line-height: 1;
      color: rgba(44,123,182, 0.9);
      content: "\25B6";
      position: absolute;
      text-align: center;
    }
    .d3-tip.w:after {
      content: "\25B6";
      margin: -4px 0 0 -1px;
      top: 50%;
      left: 10px;
      position: absolute;
    }

    .d3-tip2 {
      line-height: 1;
      font-weight: bold;
      padding: 12px;
      background: rgba(37,37,37, 0.9);
      color: #fff;
      border-radius: 5px;
    }
    .d3-tip2:after {
      box-sizing: border-box;
      display: inline;
      font-size: 10px;
      width: 100%;
      line-height: 1;
      color: rgba(44,123,182, 0.9);
      content: "\25BC";
      position: absolute;
      text-align: center;
    }

    .d3-tip2.n:after {
        margin: -3px 0 0 0;
        top: 100%;
        left: 0;
    }

    .legend circle {
      fill: none;
      stroke: #ccc;
    }

    .legend text {
      fill: #777;
      font: 10px sans-serif;
      text-anchor: middle;
    }

    .clegend circle {
    fill: none;
    stroke: #ccc;
    }

    .clegend text {
      fill: #777;
      font: 10px sans-serif;
      text-anchor: middle;
    }
    
    .chart {
      float: left;
      padding-right: 5px;
      padding-bottom: 5px;
      padding-top:0;
      padding-left:0;
    }

    .background path {
      fill: none;
      stroke: #ddd;
      shape-rendering: crispEdges;
    }

    .foreground path {
      fill: none;
      stroke: steelblue;
    }

    .brush .extent {
      fill-opacity: .3;
      stroke: #fff;
      shape-rendering: crispEdges;
    }

</style>

<h1>Homework 2: Multivariate Data</h1>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jeff Baker<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<small><a href="https://github.com/jbaker22/jbaker22.github.io/blob/master/spring-2015-msan622/homework2.html">Code on GitHub</a></small>
  <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<small><a href="#writeup">Submission details (below)</a></small>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>
<body>
<div id="bubbleChart"><br><h2>Bubble Chart</h2></div>
<div id="smallMultiples"><h2>Small Multiples</h2></div>
<div id="parallelCoords"><h2>Parallel Coordinates</h2></div>
<script>

var margin = {top: 50, right: 20, bottom: 40, left: 70},
    width = 1000 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

var formatting = d3.format(",.0f");
// set color scale for regions
var color = d3.scale.category10();

// load json file and call draw function
d3.json("state.x77.json", function(error, json) {

  data = json;
  // drawBubbles(data);
  // smallMultiples(data);
  parallels(data);
});

// function to draw all bubble chart contents into "bubbleChart" div tag
function drawBubbles(data) {
    // modeled from:  
    // http://bl.ocks.org/stumpyfr/0b3fdba40287a02ee9c8
    // http://bl.ocks.org/aaizemberg/78bd3dade9593896a59d

    // functions to fade in and fade out the bubbles on mouseover
    function fade(state_division, opacity) {
        svg.selectAll("circle")
            .filter(function (d) {
                return d.state_division != state_division;
            })
            .style("opacity", opacity);
    }

    function fadeOut() {
        svg.selectAll("circle")
        .style("opacity", function (d) { opacity(d.murder); });
    }

    // set X domain to state income
    var x = d3.scale.linear()
        .domain([0, d3.max(data, function (d) { return d.state_income; })]).nice()
        .range([0, width]);

    // set Y domain to life expectancy
    var y = d3.scale.linear()
        .domain([d3.min(data, function (d) { return d.life_exp; }) - .5, 
                 d3.max(data, function (d) { return d.life_exp; })]).nice()
        .range([height, 0]);

    // set radius domain for murder rates
    var r = d3.scale.sqrt()
        .domain([d3.min(data, function (d) { return d.murder; }), 
                 d3.max(data, function (d) { return d.murder; })])
        .range([3,50]);

    // set fade levels to correspond to murder rates (r above)
    var opacity = d3.scale.sqrt()
        .domain([d3.min(data, function (d) { return d.murder; }), 
                 d3.max(data, function (d) { return d.murder; })])
        .range([1, .5]);

    // init x-axis
    var xAxis = d3.svg.axis()
        .scale(x)
        .orient("bottom"); 
    // init y-axis
    var yAxis = d3.svg.axis()
         .scale(y)
        .orient("left");

    // set plotting area
    // append a new SVG within the chart div
    var svg = d3.select("#bubbleChart").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .attr("id", "plot")
        .attr("display", "block")
        .append("g")
        .attr("transform", "translate(60,15)"); // move base coordinates over/down a bit so lines start at 0,0

    var tip = d3.tip()
      .attr('class', 'd3-tip')
      .offset([0, -15])
      .direction('w')
      .html(function(d) {
        return "<span style='font: 14px sans-serif;'>" +
                "State: " + d.state_abb + "<br>" + 
                "<span style='font: 11px sans-serif;'>Income (per capita): $" + formatting(d.state_income) + "<br>" +
                "Region: "  + d.state_division + "<br>" + 
                "Murder Rate (per 100K pop): <strong><span style='font-size: 14px; color: #fdae61;'>" + d.murder + "</span></strong>" + "</span>";
      })

    // add x-axis to plot
    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis)
        .append("text")
        .attr("x", width + 20)
        .attr("dy", "3.50em")
        .style("text-anchor", "end")
        .text("State Income (000)");

    // add y-axis to plot
    svg.append("g")
        .attr("class", "y axis")
        .call(yAxis)
        .append("text")
        .attr("x", 5)
        .attr("y", -112)
        .attr("dy", ".71em")
        .style("text-anchor", "end")
        .attr("transform", "translate(60," + 10 + "), rotate(-90)")
        .text("Life Expectancy (years)");

    // add color legend
    color_div = {}
    // assign a color for each state division
    for  (var i = 0; i < data.length; i++) {
        color_div[data[i].state_division] = color(data[i].state_division);
    };

    var legendSize = 20;  // size of the color boxes
    var legendSpace = 5;  // space between boxes
    var colors = d3.entries(color_div);

    // add legend to the plot
    var legend = svg.selectAll(".legend")
        .data(colors)
        .enter()
        .append("g")
        .attr("class", "legend")
        .attr("transform", function(d, i) {
          return "translate(30," + (i * (legendSize + legendSpace)) + ")";
          });

    // add legend color boxes
    legend.append("rect")
      .attr("width", legendSize)
      .attr("height", legendSize)
      .style("fill", function(d) { return d.value; })
      .style("opacity", .8)
      .style("stroke", "#000");

    // add legend text
    legend.append("text")
      .attr("x", legendSize + legendSpace)
      .attr("y", legendSize - legendSpace)
      .style("text-anchor", "start")
      .text(function(d) { return d.key; });

    // add circle size legend 
    // var clegend = svg.append("g")
    //     .attr("class", "clegend")
    //     .attr("transform", "translate(" + (width - 50) + "," + (height - 20) + ")")
    //   .selectAll("g")
    //     .data([1e6, 3e6, 6e6])
    //   .enter().append("g");

    // clegend.append("circle")
    //     .attr("cy", function(d) { return -r(d.murder); })
    //     .attr("r", r);

    // clegend.append("text")
    //     .attr("y", function(d) { return -2 * r(d.murder); })
    //     .attr("dy", "1.3em")
    //     .text(d3.format(".1s"));


    // calls the tooltip function
    svg.call(tip);

    // draw your bubbles
    var circles = svg.selectAll("circle")
      .data(data)
      .enter()
      .append("circle")
      .attr("cx", function(d) {return x(d.state_income); })
      .attr("cy", function(d) {return y(d.life_exp); })
      .attr("r", function(d) {return r(d.murder);})
      .style("fill", function (d) { return color(d.state_division); })
      .style("stroke", "black")
      .attr("opacity", function (d) { return opacity(d.murder); })
      .sort(order)
      .on('mouseover', function (d, i) {
          tip.show(d);
          fade(d.state_division, .1);
      })
      .on('mouseout', function (d, i) {
          tip.hide(d);
          fadeOut(d);
      });

      // function to ensure smaller circles are not overlapped by bigger ones
      function order(a,b) {
          return b.murder - a.murder;
      }
}

// function to draw small multiple bar graphs
function smallMultiples(data) {
  // http://flowingdata.com/2014/10/15/linked-small-multiples/
  // http://bl.ocks.org/officeofjane/7315455
  // http://bl.ocks.org/mbostock/9490313
  // gist.github.com/mbostock/1157787

    // reset margins for small multiples
    var margin = {top: 20, right: 130, bottom: 20, left: 20},
    width = 960 - margin.left - margin.right,
    height = 120 - margin.top - margin.bottom;

    var cat_list = ["state_pop", "state_income", "murder", "frost", "life_exp"];
        // set fade levels to correspond to values
    var opacity = d3.scale.linear()
        .domain([d3.min(data, function (d) { return d[name]; }), 
                 d3.max(data, function (d) { return d[name]; })])
        .range([1, .5]);

    // functions to fade in and fade out the bars on mouseover
    function fade(state_division, opacity) {
        svg.selectAll("rect")
            .style("fill", function(d) {return color(d.state_division);})
            .filter(function (d) {
                return d.state_division != state_division;
            })
            .style("opacity", opacity);
    }

    function fadeOut() {
        svg.selectAll("rect")
        .style("fill", "steelblue")
        .style("opacity", function (d) { opacity(d.state_division); });
    }
    
    var mult_data = [];
    var cat_data = {};
    // for each category... 
    for (var i = 0; i < cat_list.length; i++) {
        // set key: category
        var cat_data = d3.nest()
            .key(function(d) {return cat_list[i];})
            .entries(data);
        // update dictionary of category & state values
        mult_data.push(cat_data[0]);
    }

    var x = d3.scale.ordinal()
        .rangeRoundBands([0, width + 10], .1);

    // Scales. Note the inverted domain fo y-scale: bigger is up!
    var y = d3.scale.linear()
        .range([height, 0.5]);

    var xAxis = d3.svg.axis()
        .scale(x)
        .orient("bottom")
        .outerTickSize(0)
        .innerTickSize(0);

    var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left");

      // Compute the minimum and maximum year and percent across symbols.
      x.domain(data.map(function(d) { return d.state_abb; }));
      // y.domain([0, d3.max(mult_data, function(s) { return s.values[0].state_pop; })]);

      // Add an SVG element for each category, with the desired dimensions and margin.
      var svg = d3.select("#smallMultiples").selectAll("svg")
        .data(mult_data)
        .enter()
        .append("svg:svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .attr("id", "plot")
        .attr("display", "block")
        .append("g")
        .attr("transform", "translate(10,"  + margin.top + ")")
        // function to change the y-domain based on the statistic
        .each(multiple);

      svg.append("g")
          .attr("class", "x axis2")
          .attr("transform", "translate(0," + height + ")")
          .call(xAxis);

      svg.append("g")
        .append("text")
        .attr("x", width + 30)
        .attr("y", height/2)
        .attr("dy", ".71em")
        .attr("text-anchor", "start")
        .attr("font-size", "1.1em")
        .text(function(d) { 
            switch (d.key) {
                case "state_pop": return "Population"; 
                case "state_income": return "Income"; 
                case "murder": return "Murder"; 
                case "frost": return "Frost Days"; 
                case "life_exp": return "Life Expectancy"; 
            }
        });

    var tip2 = d3.tip()
      .attr('class', 'd3-tip2')
      .offset([-10, 0])
      .direction('n')
      .html(function(d) {
        return "<span style='font: 11px sans-serif;'><span style='color: " + color(d.state_division) + ";'>" + 
                d.state_division + "</span><br>" + 
                "State: <span style='color: orange;'>" + d.state_abb + "</span><br>" + 
                "Population (000): <span style='color: orange;'>" + formatting(d.state_pop) + "</span><br>" +
                "Income (per capita): <span style='color: orange;'>$" + formatting(d.state_income) + "</span><br>" + 
                "Murder: <span style='color: orange;'>" + d.murder + "</span><br>" + 
                "Frost Days: <span style='color: orange;'>" + d.frost + "</span><br>" + 
                "Life Expectancy: <span style='color: orange;'>" + d.life_exp + "</span>";
      })

      svg.call(tip2);

      function multiple(category) {
          var svg = d3.select(this);
          // console.log(svg)
          name = category.key;
          // console.log("name: ", name);
          // svg.attr("class", name)
          y.domain(d3.extent(category.values, function(d) { return d[name]; }) );

          svg.selectAll(".bar")
              .data(function(d) {return d.values;})
              .enter()
              .append("rect")
              .attr("class", "bar")
              .attr("x", function(d) { return x(d.state_abb); })
              .attr("width", x.rangeBand())
              .attr("y", function(d) { return y(d[name]); })
              .attr("height", function(d) { return height - y(d[name]); })
              .attr("opacity", function (d) { return opacity(name); })
              .style("fill", "steelblue")
              // .style("fill", function (d) { return color(d.state_division); })
              .on('mouseover', function (d) {
                  tip2.show(d);
                  fade(d.state_division, .1);
              })
              .on('mouseout', function (d) {
                  tip2.hide(d);
                  fadeOut(d);
              });
        }
}

function parallels(data) {
    // http://bl.ocks.org/mbostock/7586334

    // update dimensions
    var margin = {top: 30, right: 30, bottom: 10, left: 30},
        width = 960 - margin.left - margin.right,
        height = 500 - margin.top - margin.bottom;

    var x = d3.scale.ordinal().rangePoints([0, width], 1),
        y = {},
        dragging = {};

    var line = d3.svg.line(),
        axis = d3.svg.axis().orient("left"),
        background,
        foreground;

    var svg = d3.select("#parallelCoords").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .attr("id", "plot")
        .attr("display", "block")
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Extract the list of dimensions and create a scale for each.
    // console.log("data:", d3.values(data[0]))
    x.domain(dimensions = d3.keys(data[0]).filter(function(d) {
        if (d === "state_abb") return false;
        if (["state_name", "state_region", "state_division"].indexOf(d) > -1) {
          // console.log("I found a categorical");
            y[d] = d3.scale.ordinal()
            .domain(data.map(function(p) { return p[d]; }))
            .rangePoints([height, 0]);
        } else {
            y[d] = d3.scale.linear()
            .domain(d3.extent(data, function(p) { return +p[d]; })).nice()
            .range([height, 0]);
        }
        return true;
    }));

    // Add grey background lines for context
    background = svg.append("g")
        .attr("class", "background")
        .selectAll("path")
        .data(data)
        .enter().append("path")
        .attr("d", path);

    // Add colored foreground lines for focus
    foreground = svg.append("g")
        .attr("class", "foreground")
        .selectAll("path")
        .data(data)
        .enter().append("path")
        .style("stroke", function (d) { return color(d.state_division); })
        .attr("d", path);

    // Add a group element for each dimension
    var g = svg.selectAll(".dimension")
        .data(dimensions)
      .enter().append("g")
        .attr("class", "dimension")
        .attr("transform", function(d) { return "translate(" + x(d) + ")"; })
        .call(d3.behavior.drag()
          .on("dragstart", function(d) {
            dragging[d] = this.__origin__ = x(d);
            background.attr("visibility", "hidden");
          })

          .on("drag", function(d) {
            dragging[d] = Math.min(width, Math.max(0, this.__origin__ += d3.event.dx));
            foreground.attr("d", path);
            dimensions.sort(function(a, b) { return position(a) - position(b); });
            x.domain(dimensions);
            g.attr("transform", function(d) { return "translate(" + position(d) + ")"; })
          })

          .on("dragend", function(d) {
            delete this.__origin__;
            delete dragging[d];
            transition(d3.select(this)).attr("transform", "translate(" + x(d) + ")");
            transition(foreground)
                .attr("d", path);
            background
                .attr("d", path)
                .transition()
                .delay(500)
                .duration(0)
                .attr("visibility", null);
          }));

    // Add an axis and title.
    g.append("g")
        .attr("class", "axis3")
        .each(function(d) { d3.select(this).call(axis.scale(y[d])); })
      .append("text")
        .attr("text-anchor", "middle")
        .attr("y", -9)
        .text(String);
        console.log("string:", String);

    // Add and store a brush for each axis
    g.append("g")
        .attr("class", "brush")
        .each(function(d) { d3.select(this).call(y[d].brush = d3.svg.brush().y(y[d]).on("brushstart", brushstart).on("brush", brush)); })
      .selectAll("rect")
        .attr("x", -8)
        .attr("width", 16);

    function position(d) {
      var v = dragging[d];
      return v == null ? x(d) : v;
    }

    function transition(g) {
      return g.transition().duration(500);
    }

    // Returns the path for a given data point.
    function path(d) {
      return line(dimensions.map(function(p) { return [position(p), y[p](d[p])]; }));
    }

    // When brushing, don’t trigger axis dragging.
    function brushstart() {
      d3.event.sourceEvent.stopPropagation();
    }

    // Handles a brush event, toggling the display of foreground lines.
    function brush() {
      var actives = dimensions.filter(function(p) { return !y[p].brush.empty(); }),
          extents = actives.map(function(p) { return y[p].brush.extent(); });
      foreground.style("display", function(d) {
        return actives.every(function(p, i) {
          return extents[i][0] <= d[p] && d[p] <= extents[i][1];
        }) ? null : "none";
      });
    }

}


</script>

<section id="writeup">
    <h2>Submission Details</h2>
    <section id="functionality">
        <h3>Functionality List</h3>
        <p>The following features were implemented in order to reach each corresponding grade level.</p>
        <span id="c-level" style="font-size: 18"><b>C-Level</b></span><br>
            <p>Bubble Chart: income, life expectancy, and murder rates, colored by region. Implemented with tooltips. </p>
        <span id="b-level" style="font-size: 18"><b>B-Level</b></span><br>
            <p>Small Multiples: bar charts of state data by statistic. Implemented with tooltips. </p>
        <span id="a-level" style="font-size: 18"><b>A-Level</b></span><br>
            <p>Parallel Coordinates: lines colored consistently across state divisions.</p>

    </section>
    <section>
        <h3>Motivation</h3>
        <p>For the bubble chart, my goal was to examine state income against life expectancy, murder rates, and region. I chose the bubble chart since it felt easier to compare these four dimensions more clearly than a heatmap. I made most of the shapes non-opaque, since things were overlapping substantially. I outlined the circles, and enabled mouseover of regional bubbles to leverage the Gestalt principle of "foreground vs. background." </p>
        <p>For the small multiples, I made the bars the same color to more easily compare levels. On mouseover, details on the state selected pop up, with other regional states highlighted as well (again, with a focus on foreground vs. background). Additionally, for parallel coordinates, I wanted to ensure the lines were colored by region, to stay consistent throughout each plot. </p>
    </section>
</section>
</body>