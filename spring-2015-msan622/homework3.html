<!DOCTYPE html>

<meta charset="utf-8">
<head>    
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="pygment_trac.css">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <meta name="description" content="MSAN 622 Submission Page - Homework 3">
</head>
<style>
    #writeup {
        width: 100%;
    }

    #functionality {
        width: 50%;
        float: left;
        padding: 5px;
        margin-right: 15px;
    }

    #plot {
        margin-left: auto;
        margin-right: auto;
    }

    body {
      font: 11px sans-serif;
    }

    .axis path,
    .axis line {
      fill: none;
      stroke: #000;
      shape-rendering: crispEdges;
    }

    /*
    .x.axis path {
      display: none;
    }
    */

    .line {
      stroke: black;
      fill: none;
      stroke-width: 0.75px;
    }

    .line.line0 {
      stroke: steelblue;
    }

    .line.line1 {
      stroke: indianred;
    }

    .overlay {
      fill: none;
      pointer-events: all;
    }

    .focus circle {
      fill: none;
    }

    .focus circle.y0 {
      stroke: blue;
    }

    .focus circle.y1 {
      stroke: red;
    }

    .focus text {
        font: 11px sans-serif;
        text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
    }


    .focus line {
      stroke: purple;
      shape-rendering: crispEdges;
    }

    .focus line.y0 {
      stroke: steelblue;
      stroke-dasharray: 3 3;
      opacity: .5;
    }

    .focus line.y1 {
      stroke: indianred;
      stroke-dasharray: 3 3;
      opacity: .5;
    }

    .brush .extent {
      stroke: #fff;
      fill-opacity: .125;
      shape-rendering: crispEdges;
    }

    .area {
        fill: lightsteelblue;
        stroke-width: 0;
    }

</style>

<h1>Homework 3: Interactive Time Series</h1>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Jeff Baker<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<small><a href="https://github.com/jbaker22/jbaker22.github.io/blob/master/spring-2015-msan622/homework3.html">Code on GitHub</a></small>
  <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<small><a href="#writeup">Submission details (below)</a></small>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>
<body>
<div id="multiseries"><br><h2>Multi-Series Line Chart</h2></div>
<div id=""><h2>Animated Bubble Plot</h2></div>
<script>

var margin = {top: 50, right: 20, bottom: 40, left: 50},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

var formatting = d3.format(",.0f");
// set color scale for regions
var color = d3.scale.category10();

// load csv file and call draw functions
d3.csv("seatbelts.csv", function(error, csv) {

  data = csv;
  // console.log(data[0])
  multiline(data);
  // bubblePlot(data);
});

function multiline(data) {
    // http://bl.ocks.org/gniemetz/4618602
    var focus_margin = {top: 20, right: 80, bottom: 100, left: 40},
        focus_width = 960 - focus_margin.left - focus_margin.right,
        focus_height = 500 - focus_margin.top - focus_margin.bottom,
        context_margin = {top: 430, right: 80, bottom: 20, left: 40},
        context_height = 500 - context_margin.top - context_margin.bottom;

// Time(X), Y1       , Y2,   (not plotted)
// Uhrzeit, Durchschn, Anz,  Gesamt
// TOD    , Average  , Qty,  total
// 11:29,   99,        8948, 891247
// Month    drivers    DriversKilled 

// "Month","DriversKilled","drivers","front","rear","kms","PetrolPrice","VanKilled","law"
// "Jan 1969",107,1687,867,269,9059,0.102971811805368,12,0
// "Feb 1969",97,1508,825,265,7685,0.102362995884646,6,0

    var formatDate = d3.time.format("%b %Y"),
        parseDate = formatDate.parse,
        bisectDate = d3.bisector(function(d) { return d.Month; }).left,
        formatOutput0 = function(d) { return formatDate(d.Month) + " - " + d.DriversKilled; },
        formatOutput1 = function(d) { return formatDate(d.Month) + " - " + d.kms; };

    data.forEach(function(d) {
        d.Month = parseDate(d.Month);
        d.DriversKilled = +d.DriversKilled;
        d.kms = +d.kms;
        // console.log(d.Month);
    });

    // set x scales for both context and focus views
    var focus_x = d3.time.scale()
        .range([0, focus_width]),
        context_x = d3.time.scale()
        .range([0, focus_width]);

    // set y scales for both context and focus views
    var focus_y0 = d3.scale.linear()
        .range([focus_height, 0]),
        focus_y1 = d3.scale.linear()
        .range([focus_height, 0]),
        context_y0 = d3.scale.linear()
        .range([context_height, 0]),
        context_y1 = d3.scale.linear()
        .range([context_height, 0]);

    // create x-axes for focus and context
    var focus_xAxis = d3.svg.axis()
        .scale(focus_x)
        .tickFormat(d3.time.format("%b %Y"))
        .orient("bottom"),
        focus_xAxis = d3.svg.axis()
        .scale(context_x)
        .tickFormat(d3.time.format("%b %Y"))
        .orient("bottom");

    // create left and right axes for focus only
    var focus_yAxisLeft = d3.svg.axis()
        .scale(focus_y0)
        .orient("left");
        focus_yAxisRight = d3.svg.axis()
        .scale(focus_y1)
        .orient("right");

    // create brush object
    var brush = d3.svg.brush()
        .x(context_x)
        .on("brush", brush);

    // var area = d3.svg.area()
    //     .interpolate("monotone")
    //     .x(function(d) { return x(d.date); })
    //     .y0(height)
    //     .y1(function(d) { return y(d.price); });

    // var area2 = d3.svg.area()
    //     .interpolate("monotone")
    //     .x(function(d) { return x2(d.date); })
    //     .y0(height2)
    //     .y1(function(d) { return y2(d.price); });

    // draw lines from the 
    var focus_line0 = d3.svg.line()
        .interpolate("cardinal")
        .x(function(d) { return focus_x(d.Month); })
        .y(function(d) { return focus_y0(d.DriversKilled); });

    var focus_line1 = d3.svg.line()
        .interpolate("cardinal")
        .x(function(d) { return focus_x(d.Month); })
        .y(function(d) { return focus_y1(d.kms); });

    var context_line0 = d3.svg.line()
        .x(function(d) { return context_x(d.Month); })
        .y(function(d) { return context_y0(d.DriversKilled); });

    var context_line1 = d3.svg.line()
        .x(function(d) { return context_x(d.Month); })
        .y(function(d) { return context_y1(d.kms); });

    var svg = d3.select("#multiseries").append("svg")
        .attr("id", "plot")
        .attr("display", "block")
        .attr("width", focus_width + focus_margin.left + focus_margin.right)
        .attr("height", focus_height + focus_margin.top + focus_margin.bottom);

    var area = d3.svg.area()
            .interpolate("linear")
            .x(function(d) { return x(d.Month); })
            .y(function(d) { return y(d.DriversKilled); });
            // .y0(function(d) { return y(0); });


    // ensure line paths don't overlap axes
    svg.append("defs").append("clipPath")
        .attr("id", "clip")
        .append("rect")
        .attr("width", focus_width)
        .attr("height", focus_height);

    var main = svg.append("g")
        .attr("transform", "translate(" + focus_margin.left + "," + focus_margin.top + ")");

    var mini = svg.append("g")
        .attr("transform", "translate(" + context_margin.left + "," + context_margin.top + ")");

    // order dates sequentially
    data.sort(function(a, b) {
        return a.Month - b.Month;
    });

    // set domains for x, y1, and y2 for both context and focus plots
    focus_x.domain([data[0].Month, data[data.length - 1].Month]);
    focus_y0.domain([0, d3.max(data, function(d) { return d.DriversKilled; })]).nice();
    focus_y1.domain([0, d3.max(data, function(d) { return d.kms; })]).nice();
    context_x.domain(focus_x.domain());
    context_y0.domain(focus_y0.domain()).nice();
    context_y1.domain(focus_y1.domain()).nice();

    // append fill portion for time period when law was enacted
    // main.selectAll("path").data(data).enter().append("path")
    //             .attr("class", "area")
    //             .attr("d", area)
    //             .attr("fill",function(d) { return d.Month > 0 ? "orange" : "yellow"; });  

    // add clipping paths
    main.append("path")
        .datum(data)
        .attr("clip-path", "url(#clip)")
        .attr("class", "line line0")
        .attr("d", focus_line0);

    main.append("path")
        .datum(data)
        .attr("clip-path", "url(#clip)")
        .attr("class", "line line1")
        .attr("d", focus_line1);

    main.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + focus_height + ")")
        .call(focus_xAxis);

    main.append("g")
        .attr("class", "y axis axisLeft")
        .call(focus_yAxisLeft)
        .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 6)
        .attr("dy", ".71em")
        .style("text-anchor", "end")
        .text("Drivers Killed");

    main.append("g")
        .attr("class", "y axis axisRight")
        .attr("transform", "translate(" + focus_width + ", 0)")
        .call(focus_yAxisRight)
        .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", -12)
        .attr("dy", ".71em")
        .style("text-anchor", "end")
        .text("Distance Driven (km)");

    mini.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + context_height + ")")
        .call(focus_xAxis);

    // append fill portion for time period when law was enacted

    mini.append("path")
        .datum(data)
        .attr("class", "line")
        .attr("d", context_line0);

    mini.append("path")
        .datum(data)
        .attr("class", "line")
        .attr("d", context_line1);

    mini.append("g")
        .attr("class", "x brush")
        .call(brush)
        .selectAll("rect")
        .attr("y", -6)
        .attr("height", context_height + 7);

    var focus = main.append("g")
        .attr("class", "focus")
        .style("display", "none");

    // Display on the timeline
    focus.append("line")
        .attr("class", "x")
        .attr("y1", focus_y0(0) - 6)
        .attr("y2", focus_y0(0) + 6)

    // Display on the left bar
    focus.append("line")
        .attr("class", "y0")
        .attr("x1", focus_width - 6) // to the left
        .attr("x2", focus_width + 6); // to the right

    // Display on the right bar
    focus.append("line")
        .attr("class", "y1")
        .attr("x1", focus_width - 6)
        .attr("x2", focus_width + 6);

    focus.append("circle")
        .attr("class", "y0")
        .attr("r", 4);

    focus.append("text")
        .attr("class", "y0")
        .attr("dy", "1em");

    focus.append("circle")
        .attr("class", "y1")
        .attr("r", 4);

    focus.append("text")
        .attr("class", "y1")
        .attr("dy", "-1em");

    main.append("rect")
        .attr("class", "overlay")
        .attr("width", focus_width)
        .attr("height", focus_height)
        .on("mouseover", function() { focus.style("display", null); })
        .on("mouseout", function() { focus.style("display", "none"); })
        .on("mousemove", mousemove);

    function mousemove() {
        var x0 = focus_x.invert(d3.mouse(this)[0]),
        i = bisectDate(data, x0, 1),
        d0 = data[i - 1],
        d1 = data[i],
        d = x0 - d0.Month > d1.Month - x0 ? d1 : d0;
        focus.select("circle.y0").attr("transform", "translate(" + focus_x(d.Month) + "," + focus_y0(d.DriversKilled) + ")");
        focus.select("text.y0").attr("transform", "translate(" + focus_x(d.Month) + "," + focus_y0(d.DriversKilled) + ")")
            .text(formatOutput0(d));     // text for hover tooltip
        focus.select("circle.y1").attr("transform", "translate(" + focus_x(d.Month) + "," + focus_y1(d.kms) + ")");
        focus.select("text.y1").attr("transform", "translate(" + focus_x(d.Month) + "," + focus_y1(d.kms) + ")")
            .text(formatOutput1(d));   // text for hover tooltip
        focus.select(".x").attr("transform", "translate(" + focus_x(d.Month) + ",0)");
        focus.select(".y0").attr("transform", "translate(" + focus_width * -1 + ", " + focus_y0(d.DriversKilled) + ")").attr("x2", focus_width + focus_x(d.Month));
        focus.select(".y1").attr("transform", "translate(0, " + focus_y1(d.kms) + ")").attr("x1", focus_x(d.Month));
    }

    function brush() {
        focus_x.domain(brush.empty() ? context_x.domain() : brush.extent());
        main.select(".line0").attr("d", focus_line0);
        main.select(".line1").attr("d", focus_line1);
        main.select(".x.axis").call(focus_xAxis);
    }
}


function bubblePlot(data) {
    // http://bost.ocks.org/mike/nations/

    // Various accessors that specify the four dimensions of data to visualize.
    function x(d) { return d.income; }
    function y(d) { return d.lifeExpectancy; }
    function radius(d) { return d.population; }
    function color(d) { return d.region; }
    function key(d) { return d.name; }

    // Chart dimensions.
    var margin = {top: 19.5, right: 19.5, bottom: 19.5, left: 39.5},
        width = 960 - margin.right,
        height = 500 - margin.top - margin.bottom;

    // Various scales. These domains make assumptions of data, naturally.
    var xScale = d3.scale.log().domain([300, 1e5]).range([0, width]),
        yScale = d3.scale.linear().domain([10, 85]).range([height, 0]),
        radiusScale = d3.scale.sqrt().domain([0, 5e8]).range([0, 40]),
        colorScale = d3.scale.category10();

    // The x & y axes.
    var xAxis = d3.svg.axis().orient("bottom").scale(xScale).ticks(12, d3.format(",d")),
        yAxis = d3.svg.axis().scale(yScale).orient("left");

    // Create the SVG container and set the origin.
    var svg = d3.select("#chart").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Add the x-axis.
    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);

    // Add the y-axis.
    svg.append("g")
        .attr("class", "y axis")
        .call(yAxis);

    // Add an x-axis label.
    svg.append("text")
        .attr("class", "x label")
        .attr("text-anchor", "end")
        .attr("x", width)
        .attr("y", height - 6)
        .text("income per capita, inflation-adjusted (dollars)");

    // Add a y-axis label.
    svg.append("text")
        .attr("class", "y label")
        .attr("text-anchor", "end")
        .attr("y", 6)
        .attr("dy", ".75em")
        .attr("transform", "rotate(-90)")
        .text("life expectancy (years)");

    // Add the year label; the value is set on transition.
    var label = svg.append("text")
        .attr("class", "year label")
        .attr("text-anchor", "end")
        .attr("y", height - 24)
        .attr("x", width)
        .text(1800);

    // Load the data.
    d3.csv("seatbelts.csv", function(seatbelts) {

      // A bisector since many nation's data is sparsely-defined.
      var bisect = d3.bisector(function(d) { return d[0]; });

      // Add a dot per nation. Initialize the data at 1800, and set the colors.
      var dot = svg.append("g")
          .attr("class", "dots")
        .selectAll(".dot")
          .data(interpolateData(1800))
        .enter().append("circle")
          .attr("class", "dot")
          .style("fill", function(d) { return colorScale(color(d)); })
          .call(position)
          .sort(order);

      // Add a title.
      dot.append("title")
          .text(function(d) { return d.name; });

      // Add an overlay for the year label.
      var box = label.node().getBBox();

      var overlay = svg.append("rect")
            .attr("class", "overlay")
            .attr("x", box.x)
            .attr("y", box.y)
            .attr("width", box.width)
            .attr("height", box.height)
            .on("mouseover", enableInteraction);

      // Start a transition that interpolates the data based on year.
      svg.transition()
          .duration(30000)
          .ease("linear")
          .tween("year", tweenYear)
          .each("end", enableInteraction);

      // Positions the dots based on data.
      function position(dot) {
        dot .attr("cx", function(d) { return xScale(x(d)); })
            .attr("cy", function(d) { return yScale(y(d)); })
            .attr("r", function(d) { return radiusScale(radius(d)); });
      }

      // Defines a sort order so that the smallest dots are drawn on top.
      function order(a, b) {
        return radius(b) - radius(a);
      }

      // After the transition finishes, you can mouseover to change the year.
      function enableInteraction() {
        var yearScale = d3.scale.linear()
            .domain([1800, 2009])
            .range([box.x + 10, box.x + box.width - 10])
            .clamp(true);

        // Cancel the current transition, if any.
        svg.transition().duration(0);

        overlay
            .on("mouseover", mouseover)
            .on("mouseout", mouseout)
            .on("mousemove", mousemove)
            .on("touchmove", mousemove);

        function mouseover() {
          label.classed("active", true);
        }

        function mouseout() {
          label.classed("active", false);
        }

        function mousemove() {
          displayYear(yearScale.invert(d3.mouse(this)[0]));
        }
      }

      // Tweens the entire chart by first tweening the year, and then the data.
      // For the interpolated data, the dots and label are redrawn.
      function tweenYear() {
        var year = d3.interpolateNumber(1800, 2009);
        return function(t) { displayYear(year(t)); };
      }

      // Updates the display to show the specified year.
      function displayYear(year) {
        dot.data(interpolateData(year), key).call(position).sort(order);
        label.text(Math.round(year));
      }

      // Interpolates the dataset for the given (fractional) year.
      function interpolateData(year) {
        return seatbelts.map(function(d) {
          return {
            name: d.name,
            region: d.region,
            income: interpolateValues(d.income, year),
            population: interpolateValues(d.population, year),
            lifeExpectancy: interpolateValues(d.lifeExpectancy, year)
          };
        });
      }

      // Finds (and possibly interpolates) the value for the specified year.
      function interpolateValues(values, year) {
        var i = bisect.left(values, year, 0, values.length - 1),
            a = values[i];
        if (i > 0) {
          var b = values[i - 1],
              t = (year - a[0]) / (b[0] - a[0]);
          return a[1] * (1 - t) + b[1] * t;
        }
        return a[1];
      }
    });
}

</script>

<section id="writeup">
    <h2>Submission Details</h2>
    <section id="functionality">
        <h3>Functionality List</h3>
        <p>The following features were implemented in order to reach each corresponding grade level.</p>
        <span id="c-level" style="font-size: 18"><b>Basic Functionality</b></span><br>
            <ul>
              <li>Generated multi-series line plot of the data</li>
              <li>Animated time series bubble plot</li>
            </ul>
        <span id="b-level" style="font-size: 18"><b>Moderate Functionality</b></span><br>
            <ul>
              <li>Panning: click and drag the selection within "context" to shift the larger detail view</li>
              <li>Details-on-Demand: hovering shows tooltip details</li>
            </ul>
        <span id="a-level" style="font-size: 18"><b>Advanced Functionality</b></span><br>
            <ul>
              <li>Brushing: highlight a selection from the "context" chart</li>
              <li>Axes are draggable and brushable, including categorical values</li>
            </ul>

    </section>
    <section>
        <h3>Motivation</h3>
        <p>For the time series multi-line plot, I chose the template above because of it's multivariate possibilities: multiple lines</p>
    </section>
</section>
</body>